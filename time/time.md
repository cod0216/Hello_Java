# 날짜와 시간

자바는 날짜와 시간 라이브러리를 지속해서 업데이트 했다.

* **JDK 1.0 (java.util.Date)**
    * **문제점**
      * **타임존 처리 부족** : 초기 Date 클래스는 타임존(time zone)을 제대로 처리하지 못했다.
      * **불편한 날짜 시간 연산** : 날짜 간 연산이나 시간의 증감 등을 처리하기 어려웠다.
      * **불변 객체 부재** : Date 객체는 변경 가능(mutable)하여, 데이터가 쉽게 변경되 수 있었고 이로 인해 버그가 발생하기 쉬웠다.
    * **해결책**
      * JDK 1.1에서 `java.util.Calendar` 클래스 도입으로 타임존 지원 개선
      * 날짜 시간 연산을 위한 추가 메소드 제공
* **JDK 1.1 (java.util.Calendar)**
  * **문제점**
    * **사용성 저하** : Calendar는 사용하기 복잡하고 직관적이지 않았다.
    * **성능 문제** : 일부 사용 사례에서 성능이 저하되는 문제가 있었다.
    * **불변 객체 부재** : Calendar 객체도 변경 가능하여, 사이드 이펙트, 스레드 안전성 문제가 있었다.
  * **해결책**
    * Joda-Time 오픈소스 라이브러리의 도입으로 사용성, 성능, 불변성 문제 해결 

  * **Joda-Time (외부 라이브러리)**
    * **표준 라이브러리가 아님** : Joda-Time은 **외부 라이브러리**로, 자바 표준에 포함되지 않아 프로젝트에 별도로 추가해야 했다.
    * **해결책**
      * 자바 8에서 `java.time 패키지(JSR-310)`를 표준 API로 도입
* JDK(1.8) (java.time 패키지)
  * java.time 패키지는 이전 API의 문제점을 해결하면서, 사용성, 성능, 스레드 안전성, 타임존 처리 등에서 크게 개선되었다. 
  변경 불가능한 불변 객체 설계로 사이드 이펙트, 스레드 안전성 보장, 보다 직관적인 API 제공으로 날짜와 시간 연산을 단순화 했다.
  * LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Instant 등의 클래스를 포함한다.
  * Joda-Time의 많은 기능을 표준 자바 플랫폼으로 가져왔다.


* **참고**
  * 자바가 표준으로 제공했던 `Data`, `Calendar`는 사용성이 너무 떨어지고, 문제가 많은 라이브러리였다. 이런 문제를 해결하기 위해 참다참다 결국 Joda-Time이라는 오픈소스 라이브러리가 등장한다.
  Joda-Time의 편리함과 사용성 덕분에 이 라이브러리는 크게 대중화 되었다. 자바는 기존 날짜와 시간의 설걔를 반성하고, Joda-Time을 만든 개발자를 대려와서 JSR-310(java.time)이라는 새로운 자바 표준 날짜와 시간 라이브러리를 정의한다.
  실용적인 Joda-Time에 많은 자바 커뮤니티의 의견을 반영해서 좀 더 안정적이고 표준적인 날짜와 시간 라이브러리인 java.time 패키지가 성공적으로 완성되었다.
    


## 요약

**LocalDate, LocalTime, LocalDateTime**
* **LocalDate** : 날짜만 표현할 때 사용한다. 년, 월, 일을 다룬다. 예) 2013-11-21
* **LocalTime** : 시간만을 표현할 때 사용한다. 시, 분, 초를 다룬다. 예) 08:20:30.213
  * 초는 밀리초, 나노초 단위도 포함할 수 있다.
* **LocalDateTime** : LocalDate와 LocalTIme을 합한 개념이다. 예) 2013-11-21T08:20:30.213


앞에 **Local**(현지의, 특정 지역의)이 붙는 이유는 세계 시간대를 고려하지 않아서 **타임존이 적용되지 않기 때문**이다.
특정 지역의 날짜와 시간만 고려할 때 사용한다.

**ZonedDateTime, OffsetDateTime**
* **ZonedDateTime** : 시간대를 고려한 날짜와 시간을 표현할 때 사용한다. 여기에는 시간대를 표현하는 타임존이 포함된다.
  * 예) 2013-11-21T08:20:30.213+9:00[Asia/Seoul]
  * +9:00은 UTC(협정 세계시)로 부터의 시간대 차이이다. 오프셋이라 한다. 한국은 UTC보다 +9:00 시간이다.
  * Asia/Seoul은 **타임존**이라 한다. 이 타임존을 알면 **오프셋**과 **일광절약 시간제**에 대한 정보를 알 수 있다.
  * 일광 절약 시간제가 적용된다.
* **OffsetDateTime** : 시간대를 고려한 날짜와 시간을 표현할 떄 사용한다. 여기에는 타임존은 없고, UTC로 부터의 시간대 차이인 고정된 오프셋만 포함한다.
  * 예) 2013-11-21T08:20:30.213+9:00
  * 일광 정략 시간제가 적용되지 않는다. -> 타임존(Time Zone)이 빠졌다고 생각하면 됨

정리하자면 일광 절약 시간제(DST, 썸머 타임)을 알려면 타임존을 알아야 한다. 따라서 ZonedDateTime은 일광 절약 시간제를 함께 처리한다. 반면에 타임존을 알 수 없는 OffsetDateTime는 일광 절약 시간제를 처리하지 못한다.
ZonedDateTime은 시간대를 고려해야 할 때 실제 사용하는 날짜와 시간 정보를 나타내는 데 더 적합하고, OffsetDateTime은 UTC로부터의 고정된 오프셋만을 고려해야 할 때 유용하다.

**Year, Month, YearMonth, MonthDay**

년, 월, 년월, 달일을 각각 다룰 때 사용한다. (자주 사용하진 않는다)

DayOfWeek와 같이 월, 화, 수, 목, 금, 토, 일을 나타내는 클래스도 있다.

* **Instant**
  * Instant는 UTC(협정 세계시)를 기준으로 하는, 시간의 한 지점을 나타낸다. Instant는 날짜와 시간을 나노초 정밀도로 표현하며, 1970년 1월 1일 0시 0분 0초(UTC)를 기준으로 경과한 시간으로 계산된다.
  * 쉽게 이야기해서 Instant는 내부에서 초 데이터만 들어 있다. (**나노초 포함**)
  * 따라서 날짜와 시간을 계산에 사용할 때는 적합하지 않다.

**Period(년,월,일), Duration(시,분,초)**
* **시간의 개념은 크게 2가지로 표현할 수 있다.**
  * 특정 시점의 시간(시각) 
    * 이 프로젝트는 2013년 8월 16일 까지 완료해야해
    * 다음 회의는 11시 30분에 진행한다.
    * 내 생일은 8월 16일이야.
  * 시간의 간격(기간)
    * 앞으로 4년은 더 공부해야 해
    * 이 프로젝트는 3개월 남았어
    * 라면은 3분동안 끓어야 해
* **Period, Duration은 시간의 간격(기간)을 표현하는데 사용된다.**
* 시간의 간격은 영어로 amount of time(시간의 양)으로 불린다.



