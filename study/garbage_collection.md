# 가비지 컬랙션

* 가비지 컬렉션
   * 자바 언어는 메모리를 할당받는 기능은 있지만, 메모리를 반환하는 기능은 없다. 이것은 개발자로 하여금 대단히 기쁜 일이며, 프로그래밍의 부담을 대폭 줄여준다. 프로그램 내에 사용되지 않은 
   메모리(가비지)는 자바 가상 기계의 가비지 커랙션 기능에 의해 자동으로 회수된다.

## 가비지 컬렉션(garbage collection)
가비지는 더 이상 참조되지 않기 때문에 가비지가 차지하고 있는 메모리 공간은 회수되어야 한다. 가비지가 많아지면 자바 플랫폼이 응용 프로그램에게 할당해줄 수 있는 가용 메모리양이 줄어들게 된다.
시간이 지날수록 자연히 가비지가 늘어나게 되며, 최악의 경우 자바 플랫폼의 가용 메모리가 0이 되며 자바 응용프로그램은 더 이상 실행될 수 없게 된다.

이런 경우를 대비하여 자바 플랫폼은 가용 메모리가 일정 크기 이하로 줄어들면 자동으로 가비지를 회수하여 가용 메모리를 늘린다. 이것을 가비지 컬렉션이라고 부르며, 
가비지 컬렉션은 자바 플랫폼에 의해 준비된 가비지 컬렉션 스레드(garbage collection thread)에 의해 처리된다.

PC의 경우 워낙 메모리가 크기 떄문에, 가용 메모리가 거의 없어지는 극한 상황은 잘 일어나지 않아 메모리 부족으로 인한 가비지 컬렉션이 작동하는 것을 보기 쉽지 않다. 또한
자바 플랫폼 내부의 판단에 의해 가비지 컬렉션이 수행되므로 언제 가비지 컬렉션이 일어날지 알기 어렵다. 

비교적 큰 규모의 자바 프로그램 개발 경험을 가진 개발자들은 가끔 프로그램을 테스트하는 도중 프로그램의 실행이 일시적으로 중단된 것처럼 보이는 경험을 한 적 이 있을 것이다. 규모가 큰 자바 프로그램은 실행 중 비교적 많은 양의
가비지를 생산한다. 그러다가 가끔 가용 메모리가 부족해지는 경우가 있는데, 이때 가비지 컬렉터가 실행되며 응용 프로그램은 실행을 멈추고 가비지 컬렉션이 끝나기를 기다리게 되어, 사용자의 눈에는 프로그램이 중단된 것처럼 보인다. 
이런 이유로 자바는 실시간 처리 응용에는 부적합한 것으로 알려져있다.

#### 가비지 컬렉션 강제 요청
응용프로그램에서 System 또는 Runtime 객체의 gc() 메소드를 호출하면 가비지 컬렉션을 요청할 수 있다. 간단히 다음 한 줄의 코드로 가능하다.

```java
System.gc(); // 가비지 컬렉션 강제 요청
```

그러나 이 문장을 호출한 즉시 가비지 컬렉터가 작동하는 것은 아니다. 이 문장은 가비지 컬렉션이 필요하다는 요청에 불과하다.
가비지 컬렉션은 자바 플랫폼이 전적으로 판단하여 적절한 시점에 작동시킨다.

#### 제한된 메모리를 가지고 프로그래밍을 할 떄 메모리를 해제하지 않으면 어떤 문제가 발생 할 수 있을까?
메모리를 제대로 해제하지 않으면 메모리 누수가 발생한다. 이는 프로그램이 동적으로 할당한 메모리를 반환하지 않고 계속 사용
하는 상황을 나타낸다.
메모리 누수는 메모리 부족을 야기하여 프로그램이 중단될 수 있으며, 프로그램의 성능이 저하된다. 또한 예기치 못한 동작으로 버그가 발생할 ㅅ 있으며, 전체 시스템의 전반적인 안정성을 저해하여 더 나아가 다른 프로그램에도 영향을 미칠 수 있다.

**메모리 부족과 메모리 누수는 다른거다**